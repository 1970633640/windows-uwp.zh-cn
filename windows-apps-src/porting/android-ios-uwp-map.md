#适用于 Android 和 iOS 开发人员的 Windows 应用概念映射

如果你是具有 Android 或 iOS 技能和/或代码的开发人员，并且希望移动到 Windows 10 和通用 Windows 平台 (UWP)，则此资源具有在三个平台之间映射平台功能（以及你的知识）所需的一切。

另请参阅[从 iOS 移动到 UWP](ios-to-uwp-root.md) 中的移植内容。

## 用户界面 (UI)

|  **一般概念** | **Android** | **iOS** | **Windows 10 UWP** |
|  ------ | ------ | ------ | ------ |
|  **设计语言。** 一组规定平台中的应用应当具有的外观和行为的约定。 | **Android 材料设计**指南提供了一种视觉语言，供 Android 设计人员和开发人员遵循。 | **人机接口指南**为 iOS 设计人员和开发人员提供了相关建议。 | [
            **UWP Windows 应用设计**](https://dev.windows.com/design)展示了如何创建一款在所有 Windows 10 设备上都很出色的应用。 你可以在其中找到用户界面 (UI) 设计基础知识、响应式设计技术和完整详细的指南列表。<br/> |
|  **用户界面标记语言。** 一种呈现和描述 UI 及其组件的标记语言。 每个平台都提供了用于视觉编辑和标记编辑的编辑器。<br/> | 使用 **Android Studio** 或 **Eclipse** 编辑 **XML 布局**。 | 使用 Xcode 内的 **Interface Builder** 编辑 **XIB** 和**故事板**。 | 使用 **[Microsoft Visual Studio](https://www.visualstudio.com/)** 和 **[Blend for Visual Studio](https://msdn.microsoft.com/library/jj171012.aspx)** 编辑的 **[XAML](https://msdn.microsoft.com/library/windows/apps/xaml/mt185595.aspx)**。<br/><br/>[XAML 平台](https://msdn.microsoft.com/library/windows/apps/xaml/mt228259.aspx)<br/><br/>[使用 XAML 创建 UI](https://msdn.microsoft.com/library/windows/apps/xaml/mt228349.aspx)<br/><br/>[使用 XAML 定义布局](https://msdn.microsoft.com/library/windows/apps/xaml/mt228350.aspx) |
|  **内置的用户界面控件。** 由该平台提供的可重用 UI 元素，如按钮、列表控件和文本控件。 | 预建的**视图**和**视图组**类指的是小组件、布局、文本字段、容器、日期/时间控件和专家控件。 | **视图**和**控件**位于 Xcode 对象库中，并在 UIKit 用户界面目录中列出。 视图包括图像视图、选取器视图和滚动视图。 控件包括按钮、日期选取器和文本字段。 | XAML 平台为你提供了大量的**内置控件**，如按钮、列表控件、面板、文本控件、命令栏、选取器、媒体和墨迹书写。<br/><br/>[添加控件和处理事件](https://msdn.microsoft.com/library/windows/apps/xaml/mt228345.aspx) |
|  **控制事件处理。** 定义在 UI 控件内触发事件时运行的逻辑。 | **事件处理程序**和**事件侦听器**已使用 XML 或以编程方式添加。 | 控件会向**目标**发送**操作**消息。 | 你可以定义一些方法来处理**代码隐藏文件**（已附加到 XAML 页面）中 XAML 控件的事件。 **事件处理程序**始终使用代码编写。 但是，你可以将这些处理程序连接到 XAML 标记或代码中的事件。<br/><br/>[添加控件和处理事件](https://msdn.microsoft.com/library/windows/apps/xaml/mt228345.aspx)<br/><br/>[事件和路由事件概述](https://msdn.microsoft.com/library/windows/apps/xaml/mt185584.aspx) |
|  **数据绑定。** 允许应用 UI 呈现数据并可以与该数据保持同步的软件设计模式。  | 提供了**数据绑定库**，尽管仍是 Beta 版。 | iOS 中没有任何内置绑定系统。 可以以**键值观察**为基础，通过使用第三方库或编写其他代码来执行数据绑定。 控件使用委托/回调方法来获取数据。 | UWP 平台会为你处理**数据绑定**。 使用 **[{x:Bind}](https://msdn.microsoft.com/library/windows/apps/mt204783.aspx)** 标记扩展可以充分利用高性能绑定，使用 **[{Binding}](https://msdn.microsoft.com/library/windows/apps/mt204782.aspx)** 可以充分利用更多的功能。 这只是你为了选择该平台是使用**单向绑定**在 UI 中显示某个数据源中的值还是当这些值因**双向绑定**发生更改时仍按照这些值更新 UI 而配置绑定的其中一种情况。<br/><br/>[数据绑定](https://msdn.microsoft.com/library/windows/apps/mt210947.aspx) |
|  **UI 自动化。** 以编程方式访问 UI 元素、使应用可供辅助技术产访问并启用自动测试脚本与 UI 交互。 | **Text labels**、**contentDescription** 和 **hint** 值有助于确保可以自动化找到 UI 元素 Android Studio 允许你使用 **UI Automator** 和 **Espresso** 测试框架编写 UI 测试。 | **自动化检测**允许你使用**辅助功能**设置或**元素层次结构**中的元素位置编写自动 UI 测试脚本来验证元素。 | 你可以直接通过 **[UI 自动化](https://msdn.microsoft.com/library/windows/apps/ee684076.aspx)**以编程方式访问 UWP 中内置的 UI 元素。<br/>**
            [自定义的自动化对等](https://msdn.microsoft.com/library/windows/apps/mt297667.aspx)**允许你为自己的自定义 UI 类提供自动化支持。 Visual Studio 中**[编码的 UI 测试项目](https://msdn.microsoft.com/library/dd286726.aspx#VerifyingCodeUsingCUITCreate)**允许你通过 UI 自动测试整个应用程序，或者单独测试 UI。 |
|  **更改控件的外观。** 编辑大小、颜色和其他属性。 | 控件具有可以使用设计器工具以 XML 标记或编程方式编辑的**属性**。 | 控件具有可以使用 Interface Builder 中的**属性检查器**或者以编程方式编辑的**属性**。 | 你可以使用 Visual Studio 和 Blend for Visual Studio 在 XAML 标记中或以编程方式编辑控件的**属性**。<br/><br/>[添加控件和处理事件](https://msdn.microsoft.com/library/windows/apps/xaml/mt228345.aspx) |
|  **可重用视觉样式。** 以可重用格式将视觉更改应用于多个控件。 | **XML 样式**是应用于一个或多个控件的属性集。 | iOS 不支持自带的可重用视觉样式，但 UIAppearance 协议允许多个控件共享通用属性。 | 你可以创建可重用的**[样式](https://msdn.microsoft.com/library/windows/apps/xaml/windows.ui.xaml.style.aspx)**，这些样式可应用于多个控件并存储在 **[ResourceDictionary](https://msdn.microsoft.com/library/windows/apps/xaml/windows.ui.xaml.resourcedictionary.aspx)** 以便于重用。<br/><br/>[快速入门：设置控件样式](https://msdn.microsoft.com/library/windows/apps/xaml/hh465381.aspx) |
|  **编辑控件的视觉结构。** 除了修改属性或特性之外，还可以自定义控件的视觉结构，例如移动复选框下的复选框文本。 | 在 Android 中，编辑控件的视觉结构没有任何简易方法。 | 在 iOS 中，编辑控件的视觉结构没有任何简易方法。 | 若要自定义控件的视觉结构，可以在 XAML 标记中复制并编辑其**[控件模板](https://msdn.microsoft.com/library/windows/apps/xaml/windows.ui.xaml.controls.controltemplate.aspx)**。<br/><br/>[快速入门：控件模板](https://msdn.microsoft.com/library/windows/apps/xaml/hh465374.aspx)  |
|  **内置的触控笔势。** 通过处理高级别的抽象化笔势事件（例如点击和双击视图和控件）提供自定义的触控支持。 | **笔势检测器**可检测常用触控笔势，包括滚动、长按、点击、双击和投掷。 | UIKit 框架提供了内置的**笔势识别器**，可检测诸如点击、收缩、平移、轻扫、旋转和长按之类触控笔势。 | **UI 元素**允许你处理**静态笔势事件**（包括点击、双击、右键点击和按住）和**操作笔势事件**（包括滑动、轻扫、转动、收缩和拉伸）。 笔势事件属于**路由事件**并且可以通过包含子 UIElement 的父对象处理。<br/><br/>[触控交互](https://msdn.microsoft.com/library/windows/apps/mt185617.aspx)<br/><br/>[自定义用户交互 - 手势、操作和交互](https://msdn.microsoft.com/library/windows/apps/mt185599.aspx#gestures__manipulations__and_interactions) |

## 导航和应用结构

|  **一般概念** | **Android** | **iOS** | **Windows 10** |
|  ------ | ------ | ------ | ------ |
|  **布局。** 布局定义用户界面的结构。 | 布局由多个**视图组**组成（如 **LinearLayout** 和 **RelativeLayout**），它们可以嵌套其他视图组或视图。 | 布局中还有一个包含 **UIView**（可以嵌套）的 **UIViewController**。  | XAML 提供了一个灵活的布局系统，该系统由用于静态和响应式布局的**布局面板类**（如 **[Canvas](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.canvas.aspx)**、**[Grid](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.grid.aspx)**、**[RelativePanel](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.relativepanel.aspx)** 和 **[StackPanel](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.stackpanel.aspx)**）组成。 **
            [属性](https://msdn.microsoft.com/library/ms171352.aspx)**用于控制元素的大小和位置。<br/><br/>[使用 XAML 定义布局](https://msdn.microsoft.com/library/windows/apps/mt228350.aspx)<br/> |
|  **对等导航。** 通过在具有同等层次结构重要性的页面之间导航呈现用户。 | **选项卡**、**轻扫视图**和**导航箱**提供**横向导航**。 | **选项卡栏控制器**、**拆分视图控制器**和**页面视图控制器**允许在同等层次结构的页面之间导航。 | 你可以使用**[选项卡/透视](https://msdn.microsoft.com/library/windows/apps/dn997788.aspx)**在内容上方显示链接/选项卡的永久性列表。 **
            [导航窗格/拆分视图](https://msdn.microsoft.com/library/windows/apps/dn997787.aspx)**允许你在内容旁显示一列链接。<br/><br/>[导航](https://msdn.microsoft.com/library/windows/apps/mt187344.aspx)<br/><br/>[两个页面之间的对等导航](https://msdn.microsoft.com/library/windows/apps/mt465735.aspx) |
|  **分层导航。** 在层次结构的父页面和子页面之间导航。 | 当与**意图**一起用于加载其他**活动**时，**列表**、**网格列表**、**按钮**及其他控件提供**下级导航**。 | **导航控制器**允许用户在层次结构的各级别之间导航。 | **
            [中心](https://msdn.microsoft.com/library/windows/apps/dn449149.aspx)**使你可以向用户展示可以选来用于导航到子页面的内容的预览。 **
            [大纲/细节](https://msdn.microsoft.com/library/windows/apps/dn997765.aspx)**使用户可以从显示在相应细节部分旁边的项目列表中进行选取。<br/><br/>[导航](https://msdn.microsoft.com/library/windows/apps/mt187344.aspx) |
|  **“后退”按钮导航。** 在应用中进行后退导航。 | 操作栏中的**“后退”**和**“向上”**按钮使用**后退栈**提供**上级**和**临时**导航。 | **导航控制器**可以向它添加一个后退按钮。<br/> | 你可以使用**[后退堆栈属性](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.frame.backstack.aspx)**轻松地处理软件或硬件的按下后退按钮操作，该属性允许你的用户遍历**导航历史记录**。<br/><br/>[“后退”按钮导航](https://msdn.microsoft.com/library/windows/apps/mt465734.aspx) |
|  **初始屏幕。** 在应用启动时显示图像，主要是用于品牌推广。 | 默认情况下，不提供初始屏幕，并通过编辑前几个活动的**主题背景**实现。 | 应用必须具有**静态启动映像**或 **XIB/情节提要启动文件**。 | 使用**图像**和彩色背景创建初始屏幕。 [初始屏幕时间可以延长](https://msdn.microsoft.com/library/windows/apps/mt187309.aspx)。<br/><br/>[添加初始屏幕](https://msdn.microsoft.com/library/windows/apps/mt187306.aspx)<br/><br/>[初始屏幕指南](https://msdn.microsoft.com/library/windows/apps/hh465338.aspx) |

## 自定义输入

|  **一般概念** | **Android** | **iOS** | **Windows 10** |
|  ------ | ------ | ------ | ------ |
|  **语音。** 语音输入的语音识别和其他语音功能。 | 实现 **RecognizerIntent** 的任何应用（如 **Google 语音搜索**）均可以提供语音输入。 **SpeechRecognizer** 类允许应用使用 Google 的语音识别 API。 | 不存在任何内置的语音识别或语音输入 API。 | 你可以使用**[语音识别](https://msdn.microsoft.com/library/windows/apps/mt185615.aspx)** API 与前台的应用交互。 你可以使用基于语音的 **[Cortana 交互](https://msdn.microsoft.com/library/windows/apps/mt185598.aspx)**来启动前台或后台中的应用，以及与后台应用交互。<br/><br/>[语音交互](https://msdn.microsoft.com/library/windows/apps/mt185614.aspx) |
|  **自定义用户输入。** 处理键盘、鼠标、触笔和其他输入。 | 受支持的交互包括**触控**、**触控板**、**触笔**、**鼠标**和**键盘**。 报告移动和输入的方式与触控相同，但可以检测到有关**输入设备**的详细信息。 | 提供对**触控**、**Apple Pencil** 和硬件**键盘**的支持。 | 你将发现支持各种各样的交互，如**[触控](https://msdn.microsoft.com/library/windows/apps/mt185617.aspx)**、**[触控板](https://msdn.microsoft.com/library/windows/apps/mt187313.aspx)**、采用数字墨迹的**[笔/触笔](https://msdn.microsoft.com/library/windows/apps/mt187311.aspx)**、**[鼠标](https://msdn.microsoft.com/library/windows/apps/mt187308.aspx)**和**[键盘](https://msdn.microsoft.com/library/windows/apps/mt185607.aspx)**。 应用无需知道所使用的输入设备即可处理数据，并且可以访问原始输入设备数据（如果需要）。<br/><br/>[处理指针输入](https://msdn.microsoft.com/library/windows/apps/mt404610.aspx)<br/><br/>[自定义用户交互](https://msdn.microsoft.com/library/windows/apps/mt185599.aspx) |

## 数据

|  **一般概念** | **Android** | **iOS** | **Windows 10** |
|  ------ | ------ | ------ | ------ |
|  **本地应用数据。** 在本地存储与应用相关的设置和文件。 | 可以使用 **openFileOutput** 和 **openFileInput** 保存本地文件。 可以使用 **getSharedPreferences** 访问**共享首选项文件**中的设置。 | 本地文件可以存储在**应用程序支持**目录中，可以通过 **NSFileManager** 类访问。 **首选项**文件中的设置可以通过 **NSUserDefaults** 类访问。 | **
            [Windows.Storage](https://msdn.microsoft.com/library/windows/apps/xaml/br230562.aspx)** 类会为你统一处理本地数据存储。 将设置存储为 **[ApplicationDataContainer](https://msdn.microsoft.com/library/windows/apps/xaml/windows.storage.applicationdatacontainer.aspx)** 对象，可通过 **[ApplicationData.LocalSettings](https://msdn.microsoft.com/library/windows/apps/xaml/windows.storage.applicationdata.localsettings.aspx)** 属性访问。 将文件存储在 **[StorageFolder](https://msdn.microsoft.com/library/windows/apps/windows.storage.storagefolder.aspx)** 对象中，可通过 **[ApplicationData.LocalFolder](https://msdn.microsoft.com/library/windows/apps/xaml/windows.storage.applicationdata.localfolder.aspx)** 属性访问。<br/><br/>[存储和检索设置以及其他应用数据](https://msdn.microsoft.com/library/windows/apps/xaml/mt299098.aspx) |
|  **本地数据库存储。** 使用对象关系映射程序 (ORM) 将应用数据存储在关系数据库中（如果适用）。 | 提供 **SQLite** 数据库。 未内置任何 ORM。 SQL 查询使用 **SQLiteDatabase** 类运行。 | 提供 **SQLite** 数据库。 **CoreData** 是内置的对象图形框架，可以与 SQLite 结合使用并提供可与 ORM 相媲美的功能。 | 你可以使用 **SQLite** 存储数据。 **
            [实体框架](https://msdn.microsoft.com/library/windows/apps/xaml/mt592863.aspx)**是内置的 ORM，无需编写大量数据访问代码，并使你可以轻松地在不编写 SQL 的情况下查询数据库。 你可以通过 [SQLite 库](https://msdn.microsoft.com/library/windows/apps/xaml/mt592864.aspx)直接运行 SQL 查询。<br/><br/>[数据访问](https://msdn.microsoft.com/library/windows/apps/xaml/mt592862.aspx) |
|  **适用于 REST 访问的 HTTP 库。** 内置库使你可以通过 HTTP 与 Web 服务和 Web 服务器进行通信。<br/> | HTTP 库 **HttpURLConnection** 和 **Volley**。 | **NSURLSession**、**NSURLConnection** 和 **NSURLDownload**。 | 你可以使用内置的 **[HttpClient](https://msdn.microsoft.com/library/windows/apps/xaml/windows.web.http.httpclient)** API 来访问常见的 HTTP 功能（包括 GET、DELETE、PUT、POST）、常见的身份验证模式、SSL、Cookie 和进度信息。 |
|  **云备份服务。** 应用数据的平台提供的备份服务。  | Android 的 **备份管理器**在 Google 的 **Android 备份服务**中处理应用程序数据的备份。  | 用户可以配置 **iCloud 备份**来处理其备份，包括应用数据。 使用 iCloud 兼容**核心数据**、**iCloud 键值应用商店**和 **iCloud 文档存储**的应用。 | 你使用漫游 **[ApplicationData API](https://msdn.microsoft.com/library/windows/apps/windows.storage.applicationdata.aspx)**（包括 **[RoamingFolder](https://msdn.microsoft.com/library/windows/apps/windows.storage.applicationdata.roamingfolder.aspx)** 和 [**RoamingSettings**](https://msdn.microsoft.com/library/windows/apps/windows.storage.applicationdata.roamingsettings.aspx)）存储的任何应用数据将自动同步到云和用户的其他设备。 同步通过用户的 Microsoft 帐户完成。<br/><br/>[漫游应用数据指南](https://msdn.microsoft.com/library/windows/apps/hh465094.aspx) |
|  **HTTP 文件下载。** 通过 HTTP 下载大型和小型文件。 | 可以使用 **URLConnection** 和 **HTTPURLConnection** 通过 HTTP 和 FTP 进行下载，也可以使用系统**下载管理器**在后台进行下载。 | **NSURLSession** 和 **NSURLConnection** 可以用于通过 HTTP 和 FTP 下载文件。 | **
            [后台传输 API](https://msdn.microsoft.com/library/windows/apps/windows.networking.backgroundtransfer.aspx)** 使你可以可靠地通过 HTTP 和 FTP 传输文件，考虑应用暂停、连接丢失并根据连接和电池使用时间进行调整。 你还可以使用 **[HttpClient](https://msdn.microsoft.com/library/windows/apps/windows.web.http.httpclient.aspx)**，它非常适合较小的文件。<br/><br/>[选择哪一种网络技术？](https://msdn.microsoft.com/library/windows/apps/mt280235.aspx)<br/><br/>[后台传输](https://msdn.microsoft.com/library/windows/apps/mt280377.aspx) |
|  **套接字。** 创建低级别的 UDP 数据报和 TCP 套接字，以便使用自己的协议与其他设备进行通信。 | **Socket** 类提供 TCP 套接字，**DatagramSocket** 类提供 UDP 套接字。 | **NSStream** 和 **CFStream** 提供 TCP 套接字，**CFSocket** 提供 UDP 套接字。 | 你可以使用 **[DatagramSocket](https://msdn.microsoft.com/library/windows/apps/br241319)** 类通过 UDP 数据报套接字进行通信，并使用 **[StreamSocket](https://msdn.microsoft.com/library/windows/apps/br226882)** 类通过 TCP 或蓝牙 RFCOMM 进行通信。<br/><br/>[网络基础知识](https://msdn.microsoft.com/library/windows/apps/mt280233.aspx)<br/><br/>[选择哪一种网络技术？](https://msdn.microsoft.com/library/windows/apps/mt280235.aspx)<br/><br/>[套接字概述](https://msdn.microsoft.com/library/windows/apps/mt280234.aspx) |
|  **WebSockets。** 在客户端和服务器之间提供双向通信，从而启用实时数据传输。 | Android 中无任何内置 WebSockets 库。 | iOS 中无任何内置 WebSockets 库。 | 对于带有接收通知的较小消息，安全连接到支持 Websockets 的服务器可以通过 **[MessageWebSocket](https://msdn.microsoft.com/library/windows/apps/windows.networking.sockets.messagewebsocket.aspx)** 类实现，对于可以分段读取的较大的二进制文件传输，则可以通过 **[StreamWebSocket](https://msdn.microsoft.com/library/windows/apps/windows.networking.sockets.streamwebsocket.aspx)** 类实现。<br/><br/>[网络基础知识](https://msdn.microsoft.com/library/windows/apps/mt280233.aspx)<br/><br/>[选择哪一种网络技术？](https://msdn.microsoft.com/library/windows/apps/mt280235.aspx)<br/><br/>[Websocket 概述](https://msdn.microsoft.com/library/windows/apps/mt186447.aspx) |
|  **OAuth 库。** 允许访问第三方 OAuth 提供程序和内置于平台的任何帐户管理的 OAuth 库。 | 不提供任何通用 OAuth 库。 针对 OAuth 身份验证的 **GoogleAuthUtil** 类通过 Google Play 服务提供。<br/> | 不提供任何通用 OAuth 库。 **帐户框架**提供对已存储在设备上的用户帐户（如 Facebook 和 Twitter）的访问权限。 | 通用 OAuth 库 **[Web 身份验证代理](https://msdn.microsoft.com/library/windows/apps/mt270196.aspx)**允许你连接到第三方标识提供商服务。 **
            [凭据保险箱](https://msdn.microsoft.com/library/windows/apps/mt270189.aspx)**允许你的用户保存其登录名并在多台设备上使用。 **
            [Microsoft.Live](https://msdn.microsoft.com/library/windows/apps/dn896755.aspx)** 命名空间使你可以轻松地访问 Live SDK OAuth，进而访问 Microsoft 服务。<br/><br/>[身份验证和用户身份](https://msdn.microsoft.com/library/windows/apps/mt270184.aspx)<br/><br/>[Windows.Security.Authentication.Web API 文档](https://msdn.microsoft.com/library/windows/apps/windows.security.authentication.web.aspx)<br/><br/>[WebAuthenticationBroker 代码示例](https://github.com/Microsoft/Windows-universal-samples/tree/master/Samples/WebAuthenticationBroker) |

## 工具

|  **一般概念** | **Android** | **iOS** | **Windows 10** |
|  ------ | ------ | ------ | ------ |
|  **IDE。** 用于创建应用的工具集。 | **Android Studio** 和 **Eclipse**，随着 Google 推动开发人员转向使用 Android Studio。 | **Xcode** | **
            [Visual Studio](https://www.visualstudio.com/features/universal-windows-platform-vs.aspx)** 和 **[Blend for Visual Studio](https://msdn.microsoft.com/library/jj171012.aspx)** 具有对 UWP 应用进行编码、设计、连接、调试、分析、优化和测试所需的所有工具。 Visual Studio 还为你提供了适用于 Windows 10 设备的**[仿真器](https://msdn.microsoft.com/library/windows/apps/mt188754.aspx)**，以便你可以在一系列仿真设备中测试应用。<br/><br/>[适用于 UWP 的下载和工具](https://dev.windows.com/downloads) |
|  **代码整理。** 应用的基本文件夹结构，通常从初始模板中创建。 | **AndroidManifest** 文件、包含源文件的 **java** 文件夹、**res** 文件夹（带有的资源包括布局和值）、Android Studio 中的 **Gradle** 生成脚本和 Eclipse 中的 **Ant** 生成脚本。 | 源文件和**支持文件**、**Info.plist** 文件、**Main.storyboard** 和 **LaunchScreen.storyboard**。 图像存储在**资源库**中。 | 你的 UWP 应用包含应用的 XAML 和代码文件（名为 Example.xaml 和 Example.xaml.cs）、**资源文件夹**中的各种图像、起始页（如 **MainPage.xaml** 和 **MainPage.xaml.cs**）和清单。<br/><br/>[创建 Hello World 应用](https://msdn.microsoft.com/library/windows/apps/dn765018.aspx) |

## 应用生命周期

|  **一般概念** | **Android** | **iOS** | **Windows 10** |
|  ------ | ------ | ------ | ------ |
|  **应用生命周期。** 在应用启动、暂停、恢复和关闭时处理事件，以便有机会保存/还原应用程序状态并运行其他任务。 | 每个活动都有其自己的**活动生命周期**，具有**已恢复**之类的状态。 有些**生命周期回调**（如 **onResume**）在**活动类**中实现。 | **应用程序生命周期**具有**已挂起**之类的状态。 如 **applicationDidEnterBackground:** 之类的方法在**应用程序委托对象**中实现，以便在状态发生更改时运行代码。 | 应用程序具有**应用执行状态**，如 NotRunning、Activated、Running、Suspending、Suspended 和 Resuming。<br/><br/>你可以在应用中实现**[应用程序类](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.application.aspx)**方法（如 OnLaunched、OnActivated、Suspending 或 Resuming），以便在状态发生更改时运行代码。<br/><br/>[应用生命周期](https://msdn.microsoft.com/library/windows/apps/mt243287.aspx) |
|  **后台任务。** 执行后台操作并在应用不再位于前台的情况下继续运行的任务。 | 应用可以启动**服务**，这些服务可在应用不再位于前台的情况下执行后台操作。 服务有其自己的**生命周期**并且已在清单中注册。 | **后台执行**仅限于特定的任务类型。<br/><br/>应用使用 **UIBackgroundModes** 在 Info.plist 文件中声明**受支持的后台任务**。<br/><br/>系统控制后台任务何时运行以及运行时长。 | 你可以创建一个后台任务，方法是实现 **[IBackgroundTask](https://msdn.microsoft.com/library/windows/apps/windows.applicationmodel.background.ibackgroundtask.aspx)** 接口并在应用程序清单中注册该任务。 你可以将任务设置为由[**计时器**](https://msdn.microsoft.com/library/windows/apps/mt186458.aspx)、[**系统触发器**](https://msdn.microsoft.com/library/windows/apps/windows.applicationmodel.background.systemtriggertype.aspx)和[**维护触发器**](https://msdn.microsoft.com/library/windows/apps/mt185632.aspx)触发。<br/><br/>[使用后台任务支持应用](https://msdn.microsoft.com/library/windows/apps/mt299103.aspx)<br/><br/>[创建和注册后台任务](https://msdn.microsoft.com/library/windows/apps/mt299100.aspx)<br/><br/>[后台任务指南](https://msdn.microsoft.com/library/windows/apps/mt187310.aspx) |

## 性能

|  **一般概念** | **Android** | **iOS** | **Windows 10** |
|  ------ | ------ | ------ | ------ |
|  **性能最佳做法。** 有关生成快速、具有响应能力、电池使用时间较长且启动时间较短的应用的指南。 | Android 提供**性能的最佳做法**培训指南。 | iOS 提供**性能概述**文档。 | 你可以仔细阅读**[性能指南](https://msdn.microsoft.com/library/windows/apps/mt270266.aspx)**中涉及以下主题的部分：设置性能目标、测量性能、内存管理、平滑动画、高效文件系统访问以及可用于分析和性能的工具。 |
|  **响应式 UI 的视图优化。** 通过优化视图改善性能。 | 使用层次结构查看器工具优化**布局层次结构**、**重复使用布局**和加载**按需视图**，所有这些技巧都是为了帮助保持 UI 线程具有响应能力，并避免出现“应用程序无响应”对话框 (**ANR's**)。<br/> | 使用**核心动画**工具修复**离屏呈现**、**混合层**、**光栅化**的 UI 问题，有助于保持 UI 线程有响应。 | 通过几个简单的步骤即可轻松地**优化** XAML **标记**和**布局**。 这些技巧包括精简布局结构、最大程度减少元素计数和过度绘制。 <br/><br/>[保持 UI 线程有响应](https://msdn.microsoft.com/library/windows/apps/mt185403.aspx)<br/><br/>[优化 XAML 标记](https://msdn.microsoft.com/library/windows/apps/mt204779.aspx)<br/><br/>[优化 XAML 布局](https://msdn.microsoft.com/library/windows/apps/mt404609.aspx) |
|  **线程。** 使用线程来维护**响应式 UI** 并运行多个**并行任务**。 | 实现线程的方法是使用类 **Runnable**、**Handler**、**ThreadPoolExecutor** 和更高级别的 **AsyncTask**。 | 也可使用 **NSThread**、**Grand Central Dispatch** 和更高级别的 **NSOperation** 实现线程。 | 通过 **[RunAsync](https://msdn.microsoft.com/library/windows/apps/windows.system.threading.threadpool.runasync.aspx)** 将**工作项**提交到**线程池**即可使用线程。 你可以通过 **[CreateTimer](https://msdn.microsoft.com/library/windows/apps/br230590.aspx)** 使用计时器提交工作项，也可以通过 **[CreatePeriodicTimer](https://msdn.microsoft.com/library/windows/apps/br230589.aspx)** 创建重复工作项。<br/><br/>[向线程池提交工作项](https://msdn.microsoft.com/library/windows/apps/mt187339.aspx)<br/><br/>[使用计时器提交工作项](https://msdn.microsoft.com/library/windows/apps/mt187341.aspx)<br/><br/>[创建定期工作项](https://msdn.microsoft.com/library/windows/apps/mt187338.aspx)<br/><br/>[使用线程池的最佳做法](https://msdn.microsoft.com/library/windows/apps/mt187336.aspx) |
|  **异步编程。** 通过利用异步编程模式避免线程的复杂性来保持 UI 线程有响应。  | 创建你自己的异步类**需要使用线程**。 某些内置的类都是异步类。 | 创建你自己的异步类**需要使用线程**。 某些内置的类都是异步类。 | 当你创建自己的 API 时，可以使用异步模式来避免阻止主线程，例如使用 C# 和 Visual Basic 中的 **Async** 和 **Await**。 你可以使用以单词 **Async** 结尾的异步内置 API。<br/><br/>[异步编程](https://msdn.microsoft.com/library/windows/apps/mt187335.aspx)<br/><br/>[使用 C# 或 Visual Basic 调用异步 API](https://msdn.microsoft.com/library/windows/apps/mt187337.aspx) |
|  **列表视图优化。** 帮助优化数据列表的内置模式，当需要显示的数据量很大时，性能通常很差 | **ViewHolder** 设计模式用于避免多个视图查找，从而使你可以使用可重用的 UI 元素。 | 可以进行一系列的优化来改善 **UITableView** 的性能，不内置任何内容。 | 你可以使用自带 **UI 虚拟化**的 [ListView](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.listview.aspx) 和 [GridView](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.gridview.aspx) 控件，从而提供流畅的平移和滚动体验以及更快速的启动时间。 你还可以在数据源中实现 [IList](https://msdn.microsoft.com/library/windows/apps/system.collections.ilist.aspx) 和 [INotifyCollectionChanged](https://msdn.microsoft.com/library/windows/apps/system.collections.specialized.inotifycollectionchanged.aspx)，从而提供**数据虚拟化**并进一步改善性能。<br/><br/>[ListView 和 GridView UI 优化](https://msdn.microsoft.com/library/windows/apps/mt204776.aspx)<br/><br/>[ListView 和 GridView 数据虚拟化](https://msdn.microsoft.com/library/windows/apps/mt574120.aspx) |

## 盈利

|  **一般概念** | **Android** | **iOS** | **Windows 10** |
|  ------ | ------ | ------ | ------ |
|  **应用内购买。** 允许用户在你的应用中进行购买的平台功能。 | **应用内计费** 由 Google Services 提供。 产品已添加到 **Google Play 开发人员控制台**。 应用内购买通过 **Google Play 计费库**实现。 | 产品已添加到 **iTunes Connect**。 使用 **StoreKit** 框架实现应用内购买。<br/><br/>使用 **SKMutablePayment** 和 **SKPaymentQueue** 购买产品。 | 你可以为应用创建应用内产品购买，方法是[将应用内产品购买添加到应用并提交到应用商店](https://msdn.microsoft.com/library/windows/apps/mt148551.aspx)。 <br/><br/>你可以使用 **[CurrentApp 类](https://msdn.microsoft.com/library/windows/apps/windows.applicationmodel.store.currentapp.aspx)**来定义应用内购买。 <br/><br/>你可以使用 **[CurrentApp.RequestProductPurchaseAsync](https://msdn.microsoft.com/library/windows/apps/windows.applicationmodel.store.currentapp.requestproductpurchaseasync.aspx)** 来显示允许客户购买产品的 UI。<br/><br/>[启用应用内产品购买](https://msdn.microsoft.com/library/windows/apps/mt219684.aspx) |
|  **易消耗品应用内购买。** 可购买、使用并再次购买的应用内产品。 | 常规购买后通过 **consumePurchase** 将其消耗掉、使其可购买、使用并再次购买，即可启用易消耗品购买。 | 易消耗产品在 iTunes Connect 中**定义为易消耗产品**。 | 你也可以支持易消耗品，方法是[在将它们提交到应用商店时将它们的产品类型定义为“易消耗品”](https://msdn.microsoft.com/library/windows/apps/mt148534.aspx)即可。 然后，在进行易消耗品购买后调用 **[CurrentApp.ReportConsumableFulfillmentAsync](https://msdn.microsoft.com/library/windows/apps/windows.applicationmodel.store.currentapp.reportconsumablefulfillmentasync.aspx)**，以便允许客户访问它。<br/><br/>[启用易消耗品应用内购买](https://msdn.microsoft.com/library/windows/apps/mt219683.aspx) |
|  **测试应用内购买。** 使你能够测试应用内购买代码，无需将应用放在应用商店中。 | 使用**应用内计费沙盒**进行测试。  | 使用**沙盒测试人员帐户**进行测试。 | 只需使用 **[CurrentAppSimulator](https://msdn.microsoft.com/library/windows/apps/windows.applicationmodel.store.currentappsimulator.aspx)** 类代替 CurrentApp 即可测试应用内购买。<br/><br/> |
|  **试用版。** 使你能够轻松地限制内容或删除基于应用试用版的广告。 | Google Play **不对应用试用版提供正式支持**。 通过创建应用内购买并在确认该购买成功后采用相应的代码路径，即可获得试用版或删除广告。 | App Store **不对应用试用版提供正式支持**。 通过创建应用内购买并在确认该购买成功后采用相应的代码路径，即可获得试用版或删除广告。 | 在你将应用提交到应用商店时使用**[“免费试用版”选项](https://msdn.microsoft.com/library/windows/apps/mt148548.aspx)**，可提供应用的免费试用版。 然后，你可以使用 **[LicenseInformation.IsTrial](https://msdn.microsoft.com/library/windows/apps/windows.applicationmodel.store.licenseinformation.istrial.aspx)** 来检查应用的试用状态，并相应地显示不同的代码路径。 你可以注册 [LicenseChanged 事件](https://msdn.microsoft.com/library/windows/apps/windows.applicationmodel.store.licenseinformation.licensechanged)，以便用户在应用运行的同时更改试用版状态后收到通知。<br/><br/>[排除或限制试用版中的功能](https://msdn.microsoft.com/library/windows/apps/mt219685.aspx) |

## 适应多个平台

|  **一般概念** | **Android** | **iOS** | **Windows 10** |
|  ------ | ------ | ------ | ------ |
|  **自适应 UI：灵活的布局。** 采用灵活的高度和宽度支持不同的屏幕大小。 | 使用 LinearLayout 对象中的 **wrap_content** 和 **match_parent** 值，或使用 RelativeLayout 对象进行对齐，即可实现灵活的布局。 | 使用带有通用情节提要的**自适应模型**、利用带有**约束**和**特征**的**自动布局**（如应用于视图控制器的 horizontalSizeClass 和 displayScale），也可实现灵活的布局。 | 你可以使用**布局属性**和**面板**并结合固定和动态大小调整，创建流动布局。<br/><br/>[使用 XAML 定义布局 - 布局属性和面板](https://msdn.microsoft.com/library/windows/apps/mt228350.aspx#layout_overview)<br/><br/>[响应式设计 101](https://msdn.microsoft.com/library/windows/apps/dn958435.aspx) |
|  **自适应 UI：定制的布局。** 使用单独的有针对性的布局支持不同的屏幕大小。 | 使用**配置限定符**（如**小**、**大**、**LDPI** 和 **HDPI**），针对资源目录中的不同屏幕配置提供备用布局文件可允许你根据不同大小和密度的屏幕来定制自定义布局。 | 定义一个**单独的 iPhone 和 iPad 情节提要**，以便针对跨平台应用中的不同设备系列定制布局。 | 你可以通过为每个设备系列定义**不同的 XAML 标记文件**来生成定制的布局。<br/><br/>[使用 XAML 定义布局 - 定制的布局](https://msdn.microsoft.com/library/windows/apps/mt228350.aspx#tailored_layouts) |
|  **自适应 UI：响应式布局。** 响应屏幕大小的更改（如旋转），或窗口大小的更改。 | 结合使用灵活布局和 **LinearLayout** 与 **RelativeLayout**，或为不同的方向提供备用布局文件来启用响应式布局。 | 当视图的**大小**或**特征**发生更改时，将应用在情节提要中指定的**约束**。 | 你可以使用 **[VisualState](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.visualstate.aspx)**、**[VisualStateManager](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.visualstatemanager.aspx)** 和 **[AdaptiveTrigger](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.adaptivetrigger.aspx)** 轻松地在运行时重排、重新定位、调整大小、展示或替换部分 UI，以响应窗口大小更改。<br/><br/>[使用 XAML 定义布局 - 视觉状态和状态触发器](https://msdn.microsoft.com/library/windows/apps/mt228350.aspx#visual_states_and_state_triggers)<br/><br/>[响应式设计 101](https://msdn.microsoft.com/library/windows/apps/dn958435.aspx) |
|  **支持不同的设备功能。** 利用高级硬件功能，同时仍支持没有这些功能的设备。 | 使用 **PackageManager.hasSystemFeature** 在运行时对设备功能进行测试，使你可以决定是否可以运行硬件特定代码。 | 你不可以在运行时执行**单个检查**来对设备功能进行测试，以特定方法测试每项功能，以便确定是否可以运行硬件特定代码。 | 你可以将**平台扩展 SDK** 添加到程序包，以将在不同设备系列（包括手机、台式机和 IoT）中找到的其他功能作为目标。 你可以使用 **[ApiInformation API](https://msdn.microsoft.com/library/windows/apps/windows.foundation.metadata.apiinformation.aspx)** 对在运行时出现的类型和成员进行测试，并且仅当这些类型和成员存在时才能调用它们。 |
|  **支持不同的设备功能。** 利用高级硬件功能，同时仍支持没有这些功能的设备。 | 可以将 **Android 支持库** 与你的应用打包在一起，以使某些较新的 API 可用于采用较旧版本的 Android 的 API。 可以在运行时使用 **Build.Version.SDK_INT** 完成对 API 级别的测试。 | 标准运行时检查用于确定 API 是否可用，例如使用 **class** 方法来检查类是否存在，使用 **respondsToSelector:** 来检查有关类的方法。  | 你可以使用 **[ApiInformation.IsApiContractPresent](https://msdn.microsoft.com/library/windows/apps/dn949005.aspx)** 来确定是否存在带有指定主次编号的 API 合约。 你也可以使用 **[ApiInformation API](https://msdn.microsoft.com/library/windows/apps/windows.foundation.metadata.apiinformation.aspx)** 对在运行时出现的类型和成员进行测试，并且仅当这些类型和成员存在时才能调用它们。 |

## 通知

|  **一般概念** | **Android** | **iOS** | **Windows 10** |
|  ------ | ------ | ------ | ------ |
|  **磁贴和锁屏提醒。** 在主屏幕上向用户显示更新。 | **应用小组件**是应用程序中的视图，可以嵌入主屏幕并且可以接收定期更新。 Android 中**没有锁屏提醒系统**。 也没有等同的磁贴系统。 | iOS 中**没有磁贴或小组件**。 你可以向图标添加**锁屏提醒**并加上可以更改的编号，以响应本地或远程通知。 | 应用的**磁贴**可以固定到“开始”屏幕，并通过字形和编号来显示你选择的文本、图像和**锁屏提醒**。 你可以通过推送通知或按预定义计划从应用更新磁贴的内容。 磁贴具有自适应性，并且可以根据它们显示的位置进行更改。<br/><br/>[创建磁贴](https://msdn.microsoft.com/library/windows/apps/xaml/mt185605.aspx)<br/><br/>[创建自适应磁贴](https://msdn.microsoft.com/library/windows/apps/xaml/mt590880.aspx)<br/><br/>[选择通知传递方法](https://msdn.microsoft.com/library/windows/apps/xaml/mt187193.aspx)<br/><br/>[磁贴和锁屏提醒指南](https://msdn.microsoft.com/library/windows/apps/xaml/hh465403.aspx) |
|  **显示通知。** 可以显示的通知类型。 | 通知可以在**通知区域**和**通知箱**中显示，**警告通知**会在一个小浮动窗口中显示通知。 通过定义 **PendingIntent**，通知可以向自身添加操作。 | 弹出通知会以**横幅**或**警报**形式显示。 你可以将自定义操作按钮添加到使用 **UIMutableUserNotificationAction** 定义的**可操作通知**。 | 你可以创建自适应的弹出通知，称为 **Toast 通知**。 你可以使用可视内容、**操作**（可以是按钮或输入和音频）在 XML 中定义 Toast。<br/><br/>[自适应和交互式 Toast 通知](https://msdn.microsoft.com/library/windows/apps/xaml/mt631604.aspx)<br/><br/>[选择通知传递方法](https://msdn.microsoft.com/library/windows/apps/xaml/mt187193.aspx)<br/><br/>[Toast 通知指南](https://msdn.microsoft.com/library/windows/apps/xaml/hh465391.aspx) |
|  **计划本地通知。** 在计划时间由应用发送的本地通知。 | 通知和操作可使用 **NotificationCompat.Builder** 进行定义，并且可以使用 **AlarmManager** 和 **BroadcastReceiver** 在应用内进行计划和处理。 | 本地通知可以使用 **UILocalNotification** 进行创建，并且可以使用 ** UILocalNotification.scheduleLocalNotification:** 进行计划。 | 你可以使用 **[ScheduledToastNotification](https://msdn.microsoft.com/library/windows/apps/xaml/windows.ui.notifications.scheduledtoastnotification.aspx)** 计划 Toast 通知。 你可以使用 **[TileNotification class](https://msdn.microsoft.com/library/windows/apps/xaml/windows.ui.notifications.tilenotification.aspx)** 从应用发送磁贴通知，也可以使用 [ScheduledTileNotification](https://msdn.microsoft.com/library/windows/apps/xaml/windows.ui.notifications.scheduledtilenotification.aspx) 计划磁贴通知。<br/><br/>[自适应和交互式 Toast 通知](https://msdn.microsoft.com/library/windows/apps/xaml/mt631604.aspx)<br/><br/>[发送本地磁贴通知](https://msdn.microsoft.com/library/windows/apps/xaml/mt593299.aspx) |
|  **发送推送通知。** 从推送通知服务器发送并且可选择在应用内处理的通知。 | **Google 云消息**提供对 Android 的推送通知支持。 | 远程或推送通知由 **Apple 推送通知服务 (APN)** 提供。 | 你可以接收从 **Windows 推送通知服务 (WNS)** 发送的推送通知，其类型可以是磁贴、Toast、锁屏提醒或原始通知。 你可以使用 [PushNotificationReceived](https://msdn.microsoft.com/library/windows/apps/xaml/windows.networking.pushnotifications.pushnotificationchannel.pushnotificationreceived.aspx) 通知传递事件，在应用运行时接收通知。<br/><br/>[Windows 推送通知服务 (WNS) 概述](https://msdn.microsoft.com/library/windows/apps/xaml/mt187203.aspx)<br/><br/>[原始通知概述](https://msdn.microsoft.com/library/windows/apps/xaml/mt187200.aspx) |

## 媒体捕获和呈现

|  **一般概念** | **Android** | **iOS** | **Windows 10** |
|  ------ | ------ | ------ | ------ |
|  **捕获媒体。** 录制音频和视觉内容。 | 使用**意图**（如 MediaStore.ACTION_VIDEO_CAPTURE）允许使用现有的相机应用捕获媒体。 使用 **android.hardware.camera2** 或**相机**库可以实现自定义相机接口。 **MediaRecorder** API 可以用于捕获音频。 | **UIImagePickerController** 允许通过系统 UI 捕获视频和照片。 **AVFoundation** 类（如 **AVCaptureSession**）支持直接访问相机。 <br/>**AVAudioRecorder** 类支持音频录制。 | 你可以结合使用内置的相机 UI 与 **[CameraCaptureUI 类](https://msdn.microsoft.com/library/windows/apps/xaml/windows.media.capture.cameracaptureui.aspx)**来捕获照片和视频。 你可以在较低的级别上与相机进行交互，并使用 **[Windows.Media.Capture](https://msdn.microsoft.com/library/windows/apps/xaml/windows.media.capture.aspx)** 中的类（如 **[MediaCapture API](https://msdn.microsoft.com/library/windows/apps/xaml/windows.media.capture.mediacapture.aspx)**）捕获音频。 <br/><br/>[使用 CameraCaptureUI 捕获照片和视频](https://msdn.microsoft.com/library/windows/apps/xaml/mt282142.aspx)<br/><br/>[使用 MediaCapture 捕获照片和视频](https://msdn.microsoft.com/library/windows/apps/xaml/mt243896.aspx) |
|  **媒体播放。** 播放音频和视频文件。 | **MediaPlayer** 和 **AudioManager** 类用于播放音频和视频文件。 | **AVKit framework**、**AVAudioPlayer** 和 **Media Player Framework** 用于播放音频和视频文件。 | 你可以使用 **[MediaSource 类](https://msdn.microsoft.com/library/windows/apps/xaml/windows.media.core.mediasource.aspx)**、**[MediaElement](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.mediaelement.aspx)** 和 **[MediaPlayer](https://msdn.microsoft.com/library/windows/apps/windows.media.playback.mediaplayer.aspx)** 类，从源（如本地和远程文件）播放音频和视频。<br/><br/>[使用 MediaSource 的媒体播放](https://msdn.microsoft.com/library/windows/apps/xaml/mt592657.aspx) |
|  **编辑媒体。** 从现有录制文件合成新的媒体文件，并应用特效。 | 低级别的类（如 **MediaCodec**、**MediaMuxer** 和 **android.media.effect**）可用于内容编辑。 | **AV Foundation** 框架中的类（如 **AVMutableComposition**、**AVMutableVideoComposition** 和 **AVMutableAudioMix**）可用于内容编辑。 | 你可以使用 **[Windows.Media.Editing](https://msdn.microsoft.com/library/windows/apps/windows.media.editing.aspx)** API（如 **[MediaComposition](https://msdn.microsoft.com/library/windows/apps/windows.media.editing.mediacomposition.aspx)** 和 **[MediaClip](https://msdn.microsoft.com/library/windows/apps/windows.media.editing.mediaclip.aspx)**）从音频和视频文件创建媒体合成。 你可以添加视频和图像覆盖、合并视频剪辑、添加背景音频以及应用音频和视频效果。<br/><br/>[媒体合成和编辑](https://msdn.microsoft.com/library/windows/apps/mt204792.aspx) |

## 传感器

|  **一般概念** | **Android** | **iOS** | **Windows 10** |
|  ------ | ------ | ------ | ------ |
|  **传感器。** 检测设备移动、位置和环境属性。 | **传感器框架**用于访问带有类（如 **SensorManager** 和 **SensorEvent**）的硬件和软件传感器。  | **核心运动框架**用于访问原始和经过处理的传感器数据。 | 你可以使用 **[Windows.Devices.Sensors](https://msdn.microsoft.com/library/windows/apps/windows.devices.sensors.aspx)** 中的类来访问传感器读数以及从传感器接收到新读取数据时触发的事件。<br/><br/>[传感器](https://msdn.microsoft.com/library/windows/apps/xaml/mt187358.aspx) |

## 位置和映射

|  **一般概念** | **Android** | **iOS** | **Windows 10** |
|  ------ | ------ | ------ | ------ |
|  **位置。** 查找设备的**当前**位置并跟踪**位置变动**。 | Google Play 服务位置 API 使用 **getLastLocation** 和 **requestLocationUpdates** 方法，通过**融合的位置提供程序**提供对**最后已知位置**的高级别访问权限。 在 Android 库中，低级别访问权限通过 **LocationManager** 提供。 | **核心位置** **CLLocationManager** 类用于监视设备的位置，**startUpdatingLocation** 用于标准位置服务，而 **startMonitoringSignificantLocationChanges** 则用于**重大变动**位置服务。 | 你可以使用 **[Windows.Devices.Geolocation](https://msdn.microsoft.com/library/windows/apps/windows.devices.geolocation.aspx)** 中的类跟踪设备位置。 对于一次性读取，使用 **[Geolocator.GetGeopositionAsync](https://msdn.microsoft.com/library/windows/apps/br225537.aspx)**。 使用 **[Geolocator.PositionChanged](https://msdn.microsoft.com/library/windows/apps/windows.devices.geolocation.geolocator.positionchanged.aspx)** 来获取定期使用计时器的位置，或者收到位置变动通知。<br/><br/>[获取用户的位置](https://msdn.microsoft.com/library/windows/apps/mt219698.aspx) |
|  **显示地图。** 显示**交互式内置地图**并添加**目标点**。 | **Google 地图 Android API** 中的 **GoogleMap**、**MapFragment** 和 **MapView** 类允许地图嵌入在应用中。 可以使用**标记**和可自定义的 **Marker** 类显示目标点。 | 使用 **MapKit 框架**中的 **MKMapView** 类将地图嵌入 iOS 应用中。 可以使用对象类（如 **MKPointAnnotation**）和视图类（如 **MKPinAnnotationView**）向应用添加**注释**，以显示目标点。 | 你可以使用内置的 **[MapControl](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.maps.mapcontrol.aspx)** XAML 控件（提供 2D、3D 和街景视图）将地图嵌入应用中。 你可以使用类（如 **[MapIcon](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.maps.mapicon.aspx)**、**[MapPolygon](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.maps.mappolygon.aspx)** 和 **[MapPolyline](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.maps.mappolyline.aspx)**）通过图钉、图像或形状添加目标点。<br/><br/>[使用 2D、3D 和街景视图方式显示地图](https://msdn.microsoft.com/library/windows/apps/mt219695.aspx)<br/><br/>[在地图上显示目标点 (POI)](https://msdn.microsoft.com/library/windows/apps/mt219696.aspx) |
|  **地理围栏。** 监视进入和离开特定地理区域。 | 使用 Google Play Services SDK 中的**定位服务**监视地理围栏。 | 使用 **CLCircularRegion** 类监视区域，使用 **CLLocationManager.startMonitoringForRegion:** 注册区域。 | 你可以使用 **[Geofence](https://msdn.microsoft.com/library/windows/apps/windows.devices.geolocation.geofencing.geofence.aspx)** 类创建地理围栏，并定义**监视状态**（如进入或离开某个区域）。 使用 **[GeofenceMonitor 类](https://msdn.microsoft.com/library/windows/apps/windows.devices.geolocation.geofencing.geofencemonitor.aspx)**处理前台地理围栏事件，后台地理围栏事件要使用 **[LocationTrigger 后台类](https://msdn.microsoft.com/library/windows/apps/windows.applicationmodel.background.locationtrigger.aspx)**处理。<br/><br/>[设置地理围栏](https://msdn.microsoft.com/library/windows/apps/mt219702.aspx) |
|  **地理编码和反向地理编码。** 将地址转换为地理位置（地理编码），将地理位置转换为地址（反向地理编码）。<br/> | **Geocoder** 类用于地理编码和反向地理编码。 | **CLGeocoder** 类用于地理编码。 | 你可以使用 **[Windows.Services.Maps](https://msdn.microsoft.com/library/windows/apps/windows.services.maps.aspx)** 中的 **[MapLocationFinder 类](https://msdn.microsoft.com/library/windows/apps/windows.services.maps.maplocationfinder.aspx)**执行地理编码。 对于地理编码，使用 **[FindLocationsAsync](https://msdn.microsoft.com/library/windows/apps/windows.services.maps.maplocationfinder.findlocationsasync.aspx)**，而对于反地理编码，使用 **[FindLocationsAtAsync](https://msdn.microsoft.com/library/windows/apps/windows.services.maps.maplocationfinder.findlocationsatasync.aspx)**。<br/><br/>[执行地理编码和反向地理编码](https://msdn.microsoft.com/library/windows/apps/mt219697.aspx) |
|  **路线和方向。** 提供两个地理位置之间的路线、距离和方向。 | Google 提供的 Web 服务 **Google 地图路线 API** 可以在 Android 上使用，即使没有提供 SDK。 | 地图工具包提供 **MKDirections** API，可用于获取有关路线和方向的信息。 | 你可以使用 **[Windows.Services.Maps](https://msdn.microsoft.com/library/windows/apps/windows.services.maps.aspx)** 中的 **[MapRouteFinder](https://msdn.microsoft.com/library/windows/apps/windows.services.maps.maproutefinder.aspx)** 类，请求步行或驾车路线。 路线会作为 **[MapRoute](https://msdn.microsoft.com/library/windows/apps/windows.services.maps.maproute.aspx)** 实例返回，并清楚地在 MapControl 上显示。 方向会在 **[MapRouteManeuver](https://msdn.microsoft.com/library/windows/apps/windows.services.maps.maproutemaneuver.aspx)** 对象内部返回。<br/><br/>[在地图上显示路线和方向](https://msdn.microsoft.com/library/windows/apps/mt219701.aspx) |

## 应用到应用的通信

|  **一般概念** | **Android** | **iOS** | **Windows 10** |
|  ------ | ------ | ------ | ------ |
|  **调用另一个应用。** 启动另一个应用，并且可以选择共享数据（如链接、文本、照片、视频和文件）。 | 可使用**隐式意图**启动另一个应用，方法是定义**意图**中的**操作**和可选数据，并使用 **startActivityForResult** 对其进行调用。<br/> | **应用扩展**可用于向另一个应用提供对应用数据的访问权限。 **URL 方案**使 URL 可以传递到另一个应用。 | 你可以使用 **[Launcher.LaunchUriAsync](https://msdn.microsoft.com/library/windows/apps/windows.system.launcher.launchuriasync.aspx)** 启动另一个已注册 URI 的应用，或使用 **[Launcher.LaunchUriForResultsAsync](https://msdn.microsoft.com/library/windows/apps/windows.system.launcher.launchuriforresultsasync.aspx)** 针对结果进行启动，并从启动的应用重新获取数据。 你可以使用 **[Launcher.LaunchFileAsync](https://msdn.microsoft.com/library/windows/apps/hh701471.aspx)** 将文件传递到另一个应用进行处理。<br/><br/>你可以使用**共享合约**在应用之间轻松地共享数据。<br/><br/>[启动 URI 的默认应用](https://msdn.microsoft.com/library/windows/apps/mt228340.aspx)<br/><br/>[启动结果的应用](https://msdn.microsoft.com/library/windows/apps/mt269386.aspx)<br/><br/>[启动文件的默认应用](https://msdn.microsoft.com/library/windows/apps/mt299102.aspx)<br/><br/>[共享数据](https://msdn.microsoft.com/library/windows/apps/xaml/mt243293.aspx) |
|  **允许对应用进行调用。** 允许应用响应来自另一个应用的请求。 | 应用向**意图筛选器**注册**意图处理活动**，以响应来自另一个应用的隐式意图。 | 将**应用扩展**打包可使数据与其他应用共享。 应用可以使用 Info.plist 中的 **CFBundleURLTypes** 项注册**自定义 URL 方案**。 | 通过在程序包清单中注册一项**[协议](https://msdn.microsoft.com/library/windows/apps/windows.applicationmodel.activation.activationkind.aspx#Protocol)**并更新 **[Application.OnActivated](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.application.onactivated.aspx)** 事件处理程序，（可选）从而返回结果，你可以将应用注册为 **URI 方案名称**的默认处理程序。 同样，也可以通过在程序包清单中添加一项声明并处理 **[Application.OnFileActivated](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.application.onfileactivated.aspx)** 事件，将应用注册为特定文件类型的默认处理程序。<br/><br/>你可以通过在清单中将应用注册为共享目标并处理 **[Application.OnShareTargetActivated](https://msdn.microsoft.com/library/windows/apps/xaml/windows.ui.xaml.application.onsharetargetactivated.aspx)** 事件来处理共享合约请求。<br/><br/>[启动结果的应用](https://msdn.microsoft.com/library/windows/apps/mt269386.aspx)<br/><br/>[处理文件激活](https://msdn.microsoft.com/library/windows/apps/mt269385.aspx)<br/><br/>[接收数据](https://msdn.microsoft.com/library/windows/apps/xaml/mt243292.aspx) |
|  **复制和粘贴。** 在应用之间复制和粘贴文本及其他内容。 | 借助 **ClipboardManager** 和 **ClipData** 类，可以使用**剪贴板框架**实现复制和粘贴。 | 可以使用 **UIPasteboard**、**UIMenuController** 和 **UIResponderStandardEditActions** 实现复制和粘贴。 | 许多默认 XAML 控件已经支持复制和粘贴。 你可以使用 **[Windows.ApplicationModel.DataTransfer](https://msdn.microsoft.com/library/windows/apps/br205967)** 中的 **[DataPackage](https://msdn.microsoft.com/library/windows/apps/windows.applicationmodel.datatransfer.datapackage.aspx)** 和 **[Clipboard](https://msdn.microsoft.com/library/windows/apps/xaml/windows.applicationmodel.datatransfer.clipboard.aspx)** 类，自行实现复制和粘贴。<br/><br/>[复制和粘贴](https://msdn.microsoft.com/library/windows/apps/xaml/mt243291.aspx) |
|  **拖放。** 在应用之间拖放内容。 | 拖放可通过使用 **Android 拖/放框架**在单个应用程序内部实现。 | iOS 不提供任何高级别的拖放 API。 | 通过在应用中实现拖放，可以启用应用到应用、桌面到应用以及应用到桌面的拖放功能。 你可以借助 **[AllowDrop](https://msdn.microsoft.com/library/windows/apps/xaml/windows.ui.xaml.uielement.allowdrop.aspx)** 和 **[CanDrag](https://msdn.microsoft.com/library/windows/apps/xaml/windows.ui.xaml.uielement.candrag.aspx)** 属性以及 **[DragOver](https://msdn.microsoft.com/library/windows/apps/xaml/windows.ui.xaml.uielement.dragover.aspx)** 和 **[Drop](https://msdn.microsoft.com/library/windows/apps/xaml/windows.ui.xaml.uielement.drop.aspx)** 事件，在 UIElement 类中实现拖放支持。<br/><br/>[拖放](https://msdn.microsoft.com/library/windows/apps/xaml/mt227651.aspx) |

## 软件设计

|  **一般概念** | **Android** | **iOS** | **Windows 10** |
|  ------ | ------ | ------ | ------ |
|  **软件设计模式。** 针对平台推荐的或适用于平台的模式。 | 尽管 Beta 版“数据绑定框架”支持广泛使用 **Model-View-ViewModel (MVVM)** 模式，但并没有针对 Android 开发推荐或提供任何正式模式。 许多第三方文章和框架推荐使用 **Model-View-Presenter (MVP)** 和 **MVVM** 方法。 | **Model-View-Controller (MVC)** 是与 iOS 一起使用的常见模式，并且已集成到平台中。 | 在针对 UWP 进行生成时，不要局限于某一特定模式。<br/><br/>你可以使用内置的[数据绑定](https://msdn.microsoft.com/library/windows/apps/mt210947.aspx)模式以确保彻底分离数据和 UI 问题，并避免对随后会更新属性值的 UI 事件处理程序进行编码。<br/><br/>你可以通过利用第三方 MVVM 库（如 [MVVM 光工具包](https://mvvmlight.codeplex.com/)），或者滚动自己的 MVVM 库并保持逻辑退出代码隐藏来扩展数据绑定，以遵循 **Model-View-ViewModel (MVVM)** 模式。<br/><br/>[MVVM 模式](https://msdn.microsoft.com/library/hh848246.aspx)<br/><br/>[模板 10 Visual Studio 项目模板](https://github.com/Windows-XAML/Template10/wiki) |


<!--HONumber=Mar16_HO1-->



---
title: 双线性纹理筛选
description: 双线性筛选计算最接近取样点的 4 个纹素的加权平均值。
ms.assetid: 0851AD28-8246-4547-A663-47884DDDFC3E
keywords:
- 双线性纹理筛选
ms.date: 02/08/2017
ms.topic: article
ms.localizationpriority: medium
ms.openlocfilehash: 437650883b4782ca02c0daf24cc8ebed01d954f6
ms.sourcegitcommit: 49d58bc66c1c9f2a4f81473bcb25af79e2b1088d
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 12/11/2018
ms.locfileid: "8932926"
---
# <a name="bilinear-texture-filtering"></a>双线性纹理筛选


*双线性筛选*计算最接近取样点的 4 个纹素的加权平均值。 与最近点筛选相比，此筛选方法更加准确和通用。 此方法很有效，因为它是在现代图形硬件中实现的。


## <a name="span-idexamplespanspan-idexamplespanspan-idexamplespanexample"></a><span id="Example"></span><span id="example"></span><span id="EXAMPLE"></span>示例


纹理始终是从左上角的 (0.0, 0.0) 向右下角的 (1.0, 1.0) 进行线性寻址的。 纹理的线性寻址如下图所示。

![使用固态色块的 4x4 纹理的图示](images/bilinear-fig7a.png)

纹理通常看似由固态色块构成，但实际上应将纹理视为等同于光栅显像才更为准确：每个纹素均定义为位于网格单元的正中心，如下图所示。

![在网格单元的中心处定义纹素的 4x4 纹理的图示](images/bilinear-fig7b.png)

如果你要求纹理采样器在 UV 坐标 (0.375, 0.375) 处获得这种纹理的颜色，那么将得到纯红色 (255, 0, 0)。 这是有道理的，因为红色纹素单元格的中心位于 UV (0.375, 0.375)。 如果你要求采样器在 UV (0.25, 0.25) 处获得这种纹理的颜色，会怎么样？ 这并不容易，因为在 UV (0.25, 0.25) 处的点正好位于 4 个纹素的角处。

最简单的方案就是让采样器返回最近的纹素的颜色；这称为点筛选（请参见[最近点采样](nearest-point-sampling.md)），而由于粒状或块状结果，通常不期望进行点筛选。 在 UV (0.25, 0.25) 处对纹理进行点采样显示出最近点筛选的另一个微妙问题：存在与采样点等距离的四个纹素，因此不存在单个最近的纹素。 这四个纹素之一将被选择作为返回的颜色，但是选择取决于坐标是如何舍入的，这可能引入撕裂伪影（参见 SDK 中的“最近点采样”文章）。

稍微更精确和更常见的筛选方案是计算最接近采样点的 4 个纹素的加权平均值；这称为*双线性筛选*。 双线性筛选的额外计算成本通常可以忽略不计，因为此例程是在现代图形硬件中实现的。 以下是我们使用双线性筛选在几个不同的采样点处获得的颜色：

```
UV: (0.5, 0.5)
```

此点正好位于红色、绿色、蓝色和白色纹素之间的边界处。 采样器返回的颜色是灰色：

```
  0.25 * (255, 0, 0)
  0.25 * (0, 255, 0) 
  0.25 * (0, 0, 255) 
## + 0.25 * (255, 255, 255) 
------------------------
= (128, 128, 128)
```

```
UV: (0.5, 0.375)
```

此点位于红色纹素和绿色纹素之间的边界的中点。 采样器返回的颜色是黄灰色（注意，蓝色纹素和白色纹素的贡献被缩放为 0）：

```
  0.5 * (255, 0, 0)
  0.5 * (0, 255, 0) 
  0.0 * (0, 0, 255) 
## + 0.0 * (255, 255, 255) 
------------------------
= (128, 128, 0)
```

```
UV: (0.375, 0.375)
```

这是红色纹素的地址，它是返回的颜色（筛选计算中的所有其他纹素的权重都被设置为 0）：

```
  1.0 * (255, 0, 0)
  0.0 * (0, 255, 0) 
  0.0 * (0, 0, 255) 
## + 0.0 * (255, 255, 255) 
------------------------
= (255, 0, 0)
```

将这些计算与下图进行比较，可以看到如果在跨越 4×4 纹素的每个纹理地址处执行双线性筛选计算，会发生什么。

![在每个纹理地址处执行双线性筛选的 4x4 纹理的图示](images/bilinear-fig7c.jpg)

## <a name="span-idrelated-topicsspanrelated-topics"></a><span id="related-topics"></span>相关主题


[纹理筛选](texture-filtering.md)

 

 





---
title: 连接存储最佳做法
author: aablackm
description: 有关如何从连接存储获取最佳性能和体验的建议
ms.author: aablackm
ms.date: 02/27/2018
ms.topic: article
ms.prod: windows
ms.technology: uwp
keywords: xbox live, xbox, 游戏, uwp, windows 10, xbox one, 连接存储
ms.localizationpriority: medium
ms.openlocfilehash: 936b0333e826d3f9047a6905e7374e1ce9ec47ca
ms.sourcegitcommit: 4f6dc806229a8226894c55ceb6d6eab391ec8ab6
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 09/20/2018
ms.locfileid: "4091808"
---
# <a name="connected-storage-best-practices"></a>连接存储最佳做法

开发人员应将保存数据划分为逻辑组，与编写一体式保存相比，逻辑分组可独立更新。 这允许游戏减少在不同情况下写入的数据量，从而减少本地资源消耗量和上传带宽使用量。 API 还允许游戏在原子操作中更新多个数据项，原子操作或者确保完全成功，或者根本不生效（例如，在保存到一半发生灾难性故障的情况下）。

因为 Xbox One 允许用户在游戏间快速切换，所以开发人员应将其游戏设计为保持当前状态可在预计收到暂停事件时立即保存，暂停事件几乎可在任何时间发生。 为在短暂停时间范围内最大化游戏写入速度，连接存储 API 使用游戏保留外的 RAM 作为第一存储点。 然后，系统将数据存入持久存储，将其与自上次上传后写入的任何其他数据协调。 存储并进入上传队列后，系统就可以防止网络连接丢失或电源故障等各种失败。

## <a name="when-to-load-a-users-connected-storage-space-data"></a>何时加载用户的连接存储空间数据

加载用户的连接存储数据空间的执行时间可能有所不同。 应用应在主执行期间执行此操作，而不是在响应用户开始注销或在响应接收来自系统的暂停通知时执行。
一般情况下，除非游戏处于确定不需要保存功能的模式下，否则应用应在用户登录并指示要运行的需求时加载连接存储空间。 你还应该考虑将连接存储空间的加载与数据加载的长序列保持一致，以便操作可以并行执行。
应用加载用户的连接存储空间数据后，它应该保留此值以供将来保存。 将连接存储空间保留一段时间不会对性能和稳定性产生负面影响。 如果系统处于联机状态，加载连接存储空间会导致对云进行同步检查，因此，在慢速或不稳定的网络条件期间释放并重新加载用户的连接存储空间可能会导致用户看到同步 UI，直到系统超时。无需以显式方式释放连接存储空间以引起云同步。 当 `SubmitUpdatesAsync` 调用中指定的完成处理程序返回 `AsyncStatus::Completed` 后，无论应用是否释放 `ConnectedStorageSpace` 对象，系统都会处理与云之间的同步。

## <a name="when-to-save"></a>何时保存

每当应用收到暂停通知时，应用应至少保存相关数据，使系统能够为用户返回上下文适当的状态。

如果游戏设计使用定期、自动或由用户启动的保存，调用连接存储的次数可以比收到暂停通知时多；这样做是降低因断电或故障导致的风险的好方法。
如果使用 XDK 开发游戏，则当用户注销时，此用户的 User 对象保持有效，此时，应用可能会使用连接存储执行最终的保存操作。

## <a name="robustness"></a>稳定性

由于保存的数据会始终同步到云，因此，保存的数据中的 bug 和导致应用故障的应用代码可能会备份到云，并分布在设备中。 为避免用户拥有一个每次启动都会崩溃的应用，请设计应用，以确保：

-   用户可以访问应用中的一个点（用户可以在这一点管理保存的数据），即使有些保存的数据不正确。
-   应用可以自动处理损坏的数据，恢复尽可能多的数据，并将其他所有内容重新初始化为安全状态。

## <a name="use-cases-for-save-game-designs"></a>保存游戏设计的用例

可充分利用连接存储空间中的容器的游戏保存系统设计取决于应用的类型：

### <a name="single-save"></a>单一保存

对于使用单一、活动样式的保存系统的应用（例如第一人称射击）：

-   将所有数据都放入单个容器中，并始终写入由名称标识的同一个容器中。
-   考虑公开重置所有数据的选项，此选项会清除所有用户保存的数据，以防用户想从头开始运行应用，但未保留之前的进度。

### <a name="multiple-saves"></a>多个保存

对于有固定数量的保存槽位（例如，5 个）的应用，有两种使用容器保存游戏数据的方法：

-   通过为每个保存槽位使用 1 个 blob，将 5 个槽位全部存储在固定名称的容器中。 使用此方法，所有 5 个槽位将完全同步且可用，如果同步过程中失败，任何槽位都不会同步并将保持其之前的状态。 如果用户在两个不同的控制台上脱机运行应用，并将进度保存在第一个控制台的 1 号槽位和第二个控制台的 2 号槽位中，则用户必须在将两个控制台连接到 Xbox Live 时选择要保留的数据；容器的合并逻辑将产生冲突。
-   将每个槽位使用其各自的名称存储到容器中。 这样，即使在多台可能处于脱机状态的计算机中，每个槽位中也能有独立的进度。 但是，如果用户在同步中途取消，则会话期间可能只有部分槽位可用；部分容器可能尚未完成下载。 在这种情况下，系统会通知用户，同步不完整，且部分云数据不在本地控制台中。

无论使用哪种方法，应用都应该为用户提供 UI，以删除槽位中的个别保存。

### <a name="warning"></a>警告

**请不要跨容器存储依赖数据。** 请不要跨多个容器存储具有依赖关系的数据。 容器可能会因为同步不完整、断电或其他错误情况而分隔。 存储在单个容器中的数据必须保持自足和本身一致。

### <a name="tips"></a>提示

**请不要阻止用户关闭主机或导航离开。** 游戏不应阻止用户在保存时关闭主机或导航离开应用。 在 Xbox 360 上，如果用户在保存游戏时关闭系统，则不会保存用户数据。 在 Xbox One 上，你的游戏会收到暂停事件，并且有 1 秒钟的时间使用连接存储 API 来保存状态。 在完全关闭或进入低功耗状态之前，系统会确保数据已正确提交到硬盘。 如果用户弹出游戏的磁盘并运行其他磁盘，会发生同样的暂停过程。

**保留连接存储空间。** 保留 ConnectedStorageSpace 对象，而不是在每次发生读取或写入事件时尝试加载这些对象。 对于由长时间保留 ConnectedStorageSpace 导致的性能或稳定性没有负面影响。

**将数据大小维持在较小的值。** 将已保存数据大小维持在较小的值。 当主机处于联机状态时，连接存储中的所有用户数据都会上传到云中。 优化数据格式，确保将延迟和带宽使用量降到最低。

**验证用户是否不介意未保存。** 检查从 GetForUserAsync 和 SubmitUpdatesAsync 返回的 OutOfLocalStorage 错误，并询问用户，以了解其是否确实要在不保存的情况下运行。 如果用户指示需要保存游戏，请重试此操作。

**检查用户的配额并提示清除空间。** 检查 SubmitUpdatesAsync 是否返回 QuotaExceeded 错误。 如果应用收到此消息，请通知用户在释放部分空间之前无法保存任意其他数据并显示允许用户执行此操作的 UI。 每个用户都能按应用获取 256 或 64 MB 的数据，且每个 XDK 游戏都能按计算机获取 64 MB 的本地存储（对于主机来说）。

**保存菜单状态以便稍后还原。** 除保存核心游戏数据外，还应保存菜单状态和其他应用设置。 如果用户运行其他应用，然后返回到你的应用，请将其还原为上下文适当的菜单状态。
响应已登录用户的更改。 当应用暂停时，用户可以注销。 当应用继续时，它应确定已登录的用户的设置是否发生更改。 发生这种情况时，请考虑导航到应用中的适当位置（例如菜单）。

**提供 UI 以管理保存的数据。** 应用应提供允许用户管理应用中保存的数据的 UI。 对于拥有自动保存系统的应用，应用应提供重置保存的数据的选项，使用户可以重置为默认运行状态。

**确保用户始终可以访问 UI 来管理保存的游戏。** 确保即使出现有问题的保存数据，应用也可以始终访问保存的游戏的管理 UI。 如果用户的保存数据由于应用 bug 或数据损坏而无法读取，则应用应该允许用户恢复到尚未崩溃的状态，或阻止应用运行。